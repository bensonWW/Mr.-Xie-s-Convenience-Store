<?php
$sql = file_get_contents('schema.sql');
$lines = explode("\n", $sql);

$tables = [];
$currentTable = null;
$refs = [];

// Helper to determine if a type is numeric
function isNumericType($type)
{
    $type = strtolower($type);
    return strpos($type, 'int') !== false ||
        strpos($type, 'numeric') !== false ||
        strpos($type, 'decimal') !== false ||
        strpos($type, 'float') !== false ||
        strpos($type, 'double') !== false ||
        strpos($type, 'boolean') !== false ||
        strpos($type, 'tinyint') !== false;
}

foreach ($lines as $line) {
    if (preg_match('/CREATE TABLE "(\w+)" \((.*)\);/', $line, $matches)) {
        $tableName = $matches[1];
        $body = $matches[2];

        $columns = [];

        // Use str_getcsv to handle splitting by comma while respecting quotes (identifiers in double quotes)
        // Since SQL uses double quotes for IDs and single for values, we might have mixed quoting.
        // We'll trust str_getcsv with double quotes as enclosure for now (typical for identifiers).
        $defs = str_getcsv($body, ',', '"');

        foreach ($defs as $def) {
            $def = trim($def);
            if (empty($def)) continue;

            // 1. Check for Column Definition: "colname" type options...
            // Note: Since we used str_getcsv with ", stripped the surrounding quotes of the column name if it was at the start?
            // Actually str_getcsv removes enclosure characters.
            // If body is: "id" integer..., "name" varchar...
            // The first element is: id" integer... (Wait, no. leading quote might be consumed if not careful?)
            // Let's stick to regex split which preserves quotes, but improve it.
            // OR re-quote manually.
        }

        // Fallback to regex split which is generally safer for mixed SQL content if simple CSV fails
        // We want to split by comma that is at "top level" (not inside parens or quotes).
        $defs = preg_split('/,(?=(?:[^"]*"[^"]*")*[^"]*$)(?![^(]*\))/', $body);

        foreach ($defs as $def) {
            $def = trim($def);
            if (empty($def)) continue;

            // 1. Column Definition
            if (preg_match('/^"(\w+)"\s+([a-zA-Z0-9_()]+)\s*(.*)$/', $def, $colMatches)) {
                $colName = $colMatches[1];
                $type = $colMatches[2];
                $colProps = $colMatches[3];
                $settings = [];

                if (stripos($colProps, 'primary key') !== false) {
                    $settings[] = 'pk';
                    if (stripos($colProps, 'autoincrement') !== false) $settings[] = 'increment';
                }
                if (stripos($colProps, 'not null') !== false) $settings[] = 'not null';

                // Handle DEFAULT value
                if (preg_match("/default '([^']+)'/", $colProps, $dM)) {
                    $rawDefault = $dM[1];
                    if (isNumericType($type) && is_numeric($rawDefault)) {
                        $settings[] = "default: $rawDefault";
                    } else {
                        // DBML prefers double quotes for string literals
                        $settings[] = "default: \"$rawDefault\"";
                    }
                } elseif (preg_match("/default ([^ ]+)/", $colProps, $dM2)) {
                    $val = $dM2[1];
                    if (strpos($val, 'CURRENT_TIMESTAMP') !== false) {
                        $settings[] = "default: `now()`";
                    } elseif (is_numeric($val)) {
                        $settings[] = "default: $val";
                    }
                }

                $columns[$colName] = [
                    'name' => $colName,
                    'type' => $type,
                    'settings' => $settings
                ];
            }
            // 2. Table-level Primary Key
            // Regex to allow explicit quoting or not, and extra spaces
            elseif (preg_match('/primary key\s*\(\s*"?(\w+)"?\s*\)/i', $def, $pkMatches)) {
                $pkCol = $pkMatches[1];
                if (isset($columns[$pkCol])) {
                    if (!in_array('pk', $columns[$pkCol]['settings'])) {
                        $columns[$pkCol]['settings'][] = 'pk';
                    }
                }
            }
            // 3. Foreign Key
            elseif (preg_match('/foreign key\("(\w+)"\) references "(\w+)"\("(\w+)"\)/i', $def, $fkMatches)) {
                $refs[] = [
                    'from_table' => $tableName,
                    'from_col' => $fkMatches[1],
                    'to_table' => $fkMatches[2],
                    'to_col' => $fkMatches[3]
                ];
            }
        }

        $tables[$tableName] = $columns;
    }
}

echo "// DBML generated by Antigravity v3\n";
echo "Project MrXieStore {\n  database_type: 'SQLite'\n  Note: 'Generated from production schema'\n}\n\n";

foreach ($tables as $name => $cols) {
    echo "Table $name {\n";
    foreach ($cols as $col) {
        echo "  {$col['name']} {$col['type']}";
        if (!empty($col['settings'])) {
            echo " [" . implode(', ', $col['settings']) . "]";
        }
        echo "\n";
    }
    echo "}\n\n";
}

foreach ($refs as $ref) {
    echo "Ref: {$ref['from_table']}.{$ref['from_col']} > {$ref['to_table']}.{$ref['to_col']}\n";
}
